//! Common interface for reading and writting registers generated by svd2rust

#![no_std]
#![deny(missing_docs)]

mod r_vcell;
pub use r_vcell::*;
#[cfg(feature = "atomics")]
mod atomic;

use core::marker;

/// Raw register type (`u8`, `u16`, `u32`, ...)
pub trait RawReg:
    Copy
    + From<bool>
    + core::ops::BitOr<Output = Self>
    + core::ops::BitAnd<Output = Self>
    + core::ops::BitOrAssign
    + core::ops::BitAndAssign
    + core::ops::Not<Output = Self>
    + core::ops::Shl<u8, Output = Self>
{
    /// Mask for bits of width `WI`
    fn mask<const WI: u8>() -> Self;
    /// `0`
    const ZERO: Self;
    /// `1`
    const ONE: Self;
}

macro_rules! raw_reg {
    ($U:ty, $size:literal, $mask:ident) => {
        impl RawReg for $U {
            #[inline(always)]
            fn mask<const WI: u8>() -> Self {
                $mask::<WI>()
            }
            const ZERO: Self = 0;
            const ONE: Self = 1;
        }
        const fn $mask<const WI: u8>() -> $U {
            <$U>::MAX >> ($size - WI)
        }
        impl FieldSpec for $U {
            type Ux = $U;
        }
    };
}

raw_reg!(u8, 8, mask_u8);
raw_reg!(u16, 16, mask_u16);
raw_reg!(u32, 32, mask_u32);
raw_reg!(u64, 64, mask_u64);

/// Raw register type
pub trait RegisterSpec {
    /// Raw register type (`u8`, `u16`, `u32`, ...).
    type Ux: RawReg;
}

/// Raw field type
pub trait FieldSpec: Sized {
    /// Raw field type (`u8`, `u16`, `u32`, ...).
    type Ux: Copy + core::fmt::Debug + PartialEq + From<Self>;
}

/// Marker for fields with fixed values
pub trait IsEnum: FieldSpec {}

#[doc(hidden)]
pub trait FromBits<U> {
    unsafe fn from_bits(b: U) -> Self;
}

#[doc(hidden)]
pub trait ToBits<U> {
    fn to_bits(&self) -> U;
}

/// Trait implemented by readable registers to enable the `read` method.
///
/// Registers marked with `Writable` can be also be `modify`'ed.
pub trait Readable: RegisterSpec {
    /// Reader struct associated with register
    type Reader: FromBits<Self::Ux>;
}

/// Trait implemented by writeable registers.
///
/// This enables the  `write`, `write_with_zero` and `reset` methods.
///
/// Registers marked with `Readable` can be also be `modify`'ed.
pub trait Writable: RegisterSpec {
    /// Writer struct associated with register
    type Writer: FromBits<Self::Ux> + ToBits<Self::Ux>;

    /// Is it safe to write any bits to register
    type Safety;

    /// Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`
    const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = Self::Ux::ZERO;

    /// Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`
    const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = Self::Ux::ZERO;
}

/// Reset value of the register.
///
/// This value is the initial value for the `write` method. It can also be directly written to the
/// register by using the `reset` method.
pub trait Resettable: RegisterSpec {
    /// Reset value of the register.
    const RESET_VALUE: Self::Ux = Self::Ux::ZERO;

    /// Reset value of the register.
    #[inline(always)]
    fn reset_value() -> Self::Ux {
        Self::RESET_VALUE
    }
}

/// Marker for register/field writers which can take any value of specified width
pub struct Safe;
/// You should check that value is allowed to pass to register/field writer marked with this
pub struct Unsafe;
/// Marker for field writers are safe to write in specified inclusive range
pub struct Range<const MIN: u64, const MAX: u64>;
/// Marker for field writers are safe to write in specified inclusive range
pub struct RangeFrom<const MIN: u64>;
/// Marker for field writers are safe to write in specified inclusive range
pub struct RangeTo<const MAX: u64>;
